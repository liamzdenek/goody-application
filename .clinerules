# Goody Dashboard Project Intelligence

## Project-Specific Patterns
- **NX Monorepo**: All packages go in `packages/` directory with single `dist/` output
- **Manual Refresh Pattern**: User-controlled data updates, no auto-refresh timers
- **Hardcoded Vendor Strategy**: Backfill uses static vendor list, not dynamic data
- **Simple Reliability**: (ARRIVED orders / total completed orders) * 100 - no complex weighting
- **Data Retention**: 30-day orders, 6-month reports - implement as TTL in DynamoDB

## Technical Constraints
- **Router Choice**: TanStack Router explicitly chosen over React Router
- **CSS Strategy**: CSS modules only, no Tailwind or frameworks
- **AWS SDK**: Must be bundled, not marked as external
- **Build Validation**: Always clean + rebuild + validate after config changes
- **CloudWatch Logs**: Always "sleep 10 && [command]" when checking logs

## User Experience Principles
- **Dropbox Design**: Flat, transparent buttons with thick black borders
- **Color Strategy**: Bold and vibrant colors mixed with pastels
- **Manual Control**: Users control refresh timing
- **No Authentication**: Demo app, auth completely out of scope

## Implementation Order
1. ✅ NX workspace + shared types package
2. ✅ Backend Lambda functions with Express API
3. ✅ All data layer Lambda functions (order simulator, report generator, data backfill)
4. ✅ CDK infrastructure deployment (COMPLETE)
5. ✅ Incremental testing and validation (DATA LAYER COMPLETE)
6. Frontend React dashboard
7. curl/AWS CLI testing scripts

## Critical Dependencies
- **Shared Types**: Frontend/backend cannot import from each other
- **Environment Variables**: Pass AWS ARNs/locations to all services
- **Health Checks**: Must validate all dependencies
- **Structured Logging**: Include correlation IDs and debug info

## Data Patterns
- **Order Lifecycle**: PLACED → SHIPPING_ON_TIME/DELAYED → Terminal status
- **Report Generation**: DynamoDB Stream triggers metric calculations
- **Vendor Backfill**: 8-12 vendors with varied reliability (0.7-0.98)
- **Historical Data**: 21-day backfill for meaningful trend analysis

## Backend Implementation Patterns
- **API Structure**: Express with serverless-http wrapper for Lambda
- **Type Safety**: Import all types from shared package, extend Express Request interface
- **Error Handling**: Use createApiError from shared package with correlation IDs
- **Mock Data**: Use correct enum values (ARRIVED not DELIVERED, 'tech' not 'GIFT_CARD')
- **Correlation IDs**: UUID-based request tracking for debugging
- **CORS Setup**: Use CORS_HEADERS from shared package for consistent headers
- **Build Process**: Path mapping in tsconfig.base.json resolves workspace dependencies
- **Order Simulator Logic**: PLAN.md decision tree - count non-terminal orders, if < 100 then 40% chance new order, else update existing
- **Status Transitions**: Realistic order lifecycle with vendor reliability-based progression
- **EventBridge Events**: Publish status changes to trigger report generation

## Deployment Strategy
- **Cloud-Native Only**: No local development, use actual AWS deployments
- **CDK Compilation**: Compile outside CDK, import artifacts
- **Testing Strategy**: curl + AWS CLI validation, no E2E testing
- **Artifact Management**: Single dist directory with package subfolders

## Successful Deployment Results
- **API Gateway**: https://6q0ywxpbhh.execute-api.us-west-2.amazonaws.com/prod/
- **CloudFront**: https://d1fkw11r9my6ok.cloudfront.net
- **Data Backfill Function**: GoodyDashboardStack-DataBackfillFunctionAB4732C3-wmgA86juPjmT
- **Order Simulator Function**: GoodyDashboardStack-OrderSimulatorFunctionE9E5293D-lnazX88QM6AF
- **Orders Table**: GoodyDashboardStack-GoodyOrders7B4321AE-1AW2E75YVYWG5
- **Reports Table**: GoodyDashboardStack-GoodyReports496FB776-1GN9M97BI6NDT
- **EventBridge Bus**: GoodyOrderEvents
- **Stack ARN**: arn:aws:cloudformation:us-west-2:129013835758:stack/GoodyDashboardStack/8573eb10-5b3b-11f0-8dc0-02723cabd28d

## Incremental Testing Plan
1. ✅ **Data Backfill**: Test Lambda function to populate historical data (3,084 orders generated)
2. ✅ **Report Generator**: Validate DynamoDB Stream-triggered reporting (5 vendor reports auto-generated)
3. ✅ **API Implementation**: All missing endpoints implemented and validated
4. ✅ **Dashboard API Bug Fix**: Fixed TypeError in dashboard summary processing
5. **Order Simulator**: Test EventBridge-triggered order generation
6. **End-to-End Flow**: Complete order lifecycle with metrics

## Operational Learnings
- **Lambda Performance**: Data backfill ~115ms execution, Report generator ~650ms
- **Memory Usage**: 91MB for backfill, 237MB for report generation - well within limits
- **DynamoDB Streams**: Near real-time processing, reports generated within seconds
- **Event-Driven Architecture**: Complete workflow from data → streams → reports working perfectly
- **Build Process**: NX dependency chain (shared → backend → infrastructure) works seamlessly
- **CloudWatch**: Use "sleep 10 && aws logs filter-log-events" pattern for log checking
- **Deployment Speed**: 35-45s for updates vs 8+ minutes for initial stack
- **Data Validation**: Use DynamoDB scan with COUNT to verify record counts quickly
- **Vendor Reliability**: Generated realistic 79.8% overall system reliability from vendor profiles

## Infrastructure Patterns That Work
- **esbuild Lambda Bundling**: Bundle workspace dependencies, include @goody/shared package
- **CDK NodejsFunction**: Use individual handlers (*.handler) vs single entry point
- **DynamoDB TTL**: Set on ttl attribute for automatic data retention (30d orders, 6mo reports)
- **GSI Strategy**: vendorIndex and statusIndex cover all query patterns effectively
- **Environment Variables**: Pass table names and EventBridge ARNs to all Lambda functions
- **IAM Least Privilege**: CDK auto-generates appropriate permissions for each service
- **Correlation IDs**: UUID-based tracking essential for debugging distributed operations

## API Implementation Patterns
- **Express Route Structure**: Organize endpoints by resource (/api/orders, /api/vendors, /dashboard)
- **Pagination Strategy**: Base64-encoded JSON cursors for stateless pagination across DynamoDB
- **Filtering Implementation**: Use GSI queries for vendor/status filters, avoid FilterExpression for performance
- **Error Handling**: Consistent error responses with correlation IDs and structured logging
- **CORS Headers**: Use shared CORS_HEADERS constant for consistent cross-origin support
- **Activity Metrics**: Calculate recent activity from order update timestamps with configurable time windows
- **Vendor Reports**: Combine vendor metadata with performance reports from separate DynamoDB queries
- **Dashboard Summary**: Filter SYSTEM reports from vendor processing to prevent undefined access errors